import { useEffect, useReducer } from 'react';
import { useAlert } from 'react-alert';
import { useQuery, useQueryClient } from '@tanstack/react-query';

import axios from 'ajax/axios';
import { getStripeAccountLinkStatusPath } from 'ajax/endpoints';
import { SIGN_IN } from 'routes';
import useUser from './useUser';
import { USER_ROLE_ORG_ADMIN_TYPE } from 'constants/authConstants';
import { useHistory } from 'react-router-dom';
import { GENERIC_ERROR } from 'constants/textConstants';
import { User } from './useUser.types';


function getRevenueProgramIdRequiringVerification(user: User) {
  return user?.role_type?.[0] === USER_ROLE_ORG_ADMIN_TYPE &&
    user?.revenue_programs?.[0]?.payment_provider_stripe_verified === false
    ? user.revenue_programs[0].id
    : '';
}


type Action = {
  type: 'accountLinkStatusRetrieved' | 'userRetrieved' | 'apiError',
  payload?: any
};

export type UnverifiedReason = | '' | 'pending_verification' | 'past_due';

export type State = {
  requiresVerification: boolean,
  unverifiedReason: UnverifiedReason,
  parentRevenueProgramId: string,
  sendUserToStripe: Function,
  error: string,
  stripeConnectStarted: boolean
};

export const initialState: State = {
  requiresVerification: false,
  unverifiedReason: '',
  parentRevenueProgramId: '',
  sendUserToStripe: () => {},
  error: '',
  stripeConnectStarted: false,
};

function reducer(state: State, action: Action): State {
  switch (action.type) {
    case 'accountLinkStatusRetrieved':
      return {
        ...state,
        sendUserToStripe: () => {
          window.location.href = action.payload.url;
        },
        requiresVerification: action.payload.requiresVerification,
        unverifiedReason: action.payload.reason,
        stripeConnectStarted: action.payload.stripeConnectStarted,
      };
    case 'userRetrieved':
      const parentRevenueProgramId = getRevenueProgramIdRequiringVerification(action.payload);
      return { ...state, parentRevenueProgramId };
    case 'apiError':
      return { ...state, error: action.payload };
    default:
      return state
  }
}

async function fetchAccountLinkStatus(rpId: string) {
  // this endpoint can have a number of small side effects, including creating a stripe account link
  // and causing a stripe account ID to be added to the RP's payment provider. Because of this, it uses
  // POST as opposed to GET
  try {
    const { data } = await axios.post(getStripeAccountLinkStatusPath(rpId), {});
    return data;
  } catch (err) {
    throw new Error('Unable to fetch account link status')
  }
}

export default function useConnectStripeAccount() {
  const alert = useAlert();
  const { user, isError: useUserIsError } = useUser();
  const queryClient = useQueryClient();
  const history = useHistory();

  const [state, dispatch] = useReducer(reducer, initialState);

  useEffect(() => {
    if (user) {
      dispatch({ type: 'userRetrieved', payload: user });
    }
  }, [user]);

  useEffect(() => {
    if (useUserIsError) {
      dispatch({type: 'apiError', payload: 'Something went wrong when accessing the user'});
    }
  }, [useUserIsError]);

  const { isLoading: stripeAccountLinkStatusLoading } = useQuery(
    ['stripeAccountLinkStatus'],
    () => fetchAccountLinkStatus(state.parentRevenueProgramId),
    {
      enabled: !!state.parentRevenueProgramId,
      // refetchInterval: 30000, // in ms, so 30 seconds. note this won't happen if app browser tab is inactive
      onSuccess: (data) => {
        if (!data.requiresVerification) {
          // NB: `['user']` is meant to refer to a named query generated by useQuery call
          // in custom useUser hook. This will cause the user to be refetched,
          // the user's revenue program should now appear as having Stripe verified, which will
          // in turn hide the Stripe Account Link CTAs.
          queryClient.invalidateQueries(['user']);
        }
        dispatch({ type: 'accountLinkStatusRetrieved', payload: data });
      },
      onError: (err: any) => {

        console.error('error happened')
        if (err?.name === 'AuthenticationError') {
          history.push(SIGN_IN);
        } else {
          console.error(err);
          alert.error(GENERIC_ERROR);
          dispatch({type: 'apiError', payload: 'Something went wrong when accessing account link status'});
        }
      }
    }
  );
  return {
    loading: stripeAccountLinkStatusLoading,
    requiresVerification: state.requiresVerification,
    unverifiedReason: state.unverifiedReason,
    sendUserToStripe: state.sendUserToStripe,
    error: state.error,
    stripeConnectStarted: state.stripeConnectStarted,
  };
}
