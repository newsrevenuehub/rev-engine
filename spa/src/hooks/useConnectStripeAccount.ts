import { useEffect, useReducer } from 'react';
import { useAlert } from 'react-alert';
import { useQuery, useQueryClient } from '@tanstack/react-query';

import axios from 'ajax/axios';
import { getStripeAccountLinkStatusPath } from 'ajax/endpoints';
import { SIGN_IN } from 'routes';
import useUser from './useUser';
import { USER_ROLE_ORG_ADMIN_TYPE } from 'constants/authConstants';
import { useHistory } from 'react-router-dom';
import { GENERIC_ERROR } from 'constants/textConstants';
import { User } from './useUser.types';


function getRevenueProgramIdRequiringVerification(user: User) {
  return user?.role_type?.[0] === USER_ROLE_ORG_ADMIN_TYPE &&
    user?.revenue_programs?.[0]?.payment_provider_stripe_verified === false
    ? user.revenue_programs[0].id
    : '';
}


type Action = {
  type: 'accountLinkStatusRetrieved' | 'userRetrieved' | 'apiError',
  payload?: any
};

export type UnverifiedReason = | '' | 'pending_verification' | 'past_due';

type State = {
  requiresVerification: boolean,
  unverifiedReason: UnverifiedReason,
  parentRevenueProgramId: string,
  sendUserToStripe: Function,
  error: string
};

const initialState: State = {
  requiresVerification: true,
  unverifiedReason: '',
  parentRevenueProgramId: '',
  sendUserToStripe: () => {},
  // ctaDescriptionText: USER_ACTION_REQUIRED_MESSAGE,
  // ctaButtonText: 'Take me to Stripe',
  error: ''
};

function reducer(state: State, action: Action): State {
  switch (action.type) {
    case 'accountLinkStatusRetrieved':
      return {
        ...state,
        sendUserToStripe: () => {
          window.location.href = action.payload.url;
        },
        requiresVerification: action.payload.requiresVerification,
        unverifiedReason: action.payload.reason,
      };
    case 'userRetrieved':
      const parentRevenueProgramId = getRevenueProgramIdRequiringVerification(action.payload);
      return { ...state, parentRevenueProgramId, requiresVerification: !!parentRevenueProgramId };
    case 'apiError':
      return { ...state, error: 'Something went wrong when accessing account link status' };
    default:
      return state
  }
}

async function fetchAccountLinkStatus(rpId: string) {
  // this endpoint can have a number of small side effects, including creating a stripe account link
  // and causing a stripe account ID to be added to the RP's payment provider. Because of this, it uses
  // POST as opposed to GET
  const { data } = await axios.post(getStripeAccountLinkStatusPath(rpId), {});
  return data;
}

export default function useConnectStripeAccount() {
  const alert = useAlert();
  const { user } = useUser();
  const queryClient = useQueryClient();
  const history = useHistory();

  const [state, dispatch] = useReducer(reducer, initialState);

  useEffect(() => {
    if (user) {
      dispatch({ type: 'userRetrieved', payload: user });
    }
  }, [user]);

  const { isLoading: stripeAccountLinkStatusLoading } = useQuery(
    ['stripeAccountLinkStatus'],
    () => fetchAccountLinkStatus(state.parentRevenueProgramId),
    {
      enabled: !!state.parentRevenueProgramId && state.requiresVerification,
      refetchInterval: 30000, // in ms, so 30 seconds. note this won't happen if app browser tab is inactive
      onSuccess: (data) => {
        if (!data.requiresVerification) {
          // NB: `['user']` is meant to refer to a named query generated by useQuery call
          // in custom useUser hook. This will cause the user to be refetched,
          // the user's revenue program should now appear as having Stripe verified, which will
          // in turn hide the Stripe Account Link CTAs.
          queryClient.invalidateQueries(['user']);
        }
        dispatch({ type: 'accountLinkStatusRetrieved', payload: data });
      },
      onError: (err: any) => {
        if (err?.name === 'AuthenticationError') {
          history.push(SIGN_IN);
        } else {
          console.error(err);
          alert.error(GENERIC_ERROR);
          dispatch({type: 'apiError'});
        }
      }
    }
  );

  return {
    loading: stripeAccountLinkStatusLoading,
    requiresVerification: state.requiresVerification,
    unverifiedReason: state.unverifiedReason,
    sendUserToStripe: state.sendUserToStripe,
    error: state.error
  };
}
